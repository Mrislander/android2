package com.elitise.firmwareupdate;
/**
 * Created by Andy.Xiang on 2/14/2017.
 */
import android.graphics.Paint;
import android.graphics.PointF;
import android.graphics.RectF;
import android.graphics.Shader;
import android.graphics.LinearGradient;
import android.graphics.RadialGradient;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Path;

/**
 * Created by ShannonGreen on 2/13/17.
 * Copyright Â© 2017 InduraPower. All rights reserved.
 *
 * Generated by PaintCode
 * http://www.paintcodeapp.com
 *
 * @author ShannonGreen
 */

public class ProgressBar {
    // Resizing Behavior

    public enum ResizingBehavior {
        AspectFit, //!< The content is proportionally resized to fit into the target rectangle.
        AspectFill, //!< The content is proportionally resized to completely fill the target rectangle.
        Stretch, //!< The content is stretched to match the entire target rectangle.
        Center, //!< The content is centered in the target rectangle, but it is NOT resized.
    }

    // Canvas Drawings

    // Tab

    public static void drawCanvas1(Canvas canvas, float percent) {
        ProgressBar.drawCanvas1(canvas, new RectF(0f, 0f, 250f, 20f), ResizingBehavior.AspectFit, percent);
    }

    public static void drawCanvas1(Canvas canvas, RectF targetFrame, ResizingBehavior resizing, float percent) {
        // General Declarations
        Paint paint;

        // Local Colors
        int color2 = Color.argb(255, 224, 70, 34);

        // Local Gradients
        PaintCodeGradient gradient = new PaintCodeGradient(new int[]{Color.BLACK, PaintCodeColor.colorByBlendingColors(Color.BLACK, 0.5f, color2), color2, color2, Color.WHITE}, new float[]{0f, 0.15f, 0.31f, 0.75f, 1f});
        PaintCodeGradient gradient2 = new PaintCodeGradient(new int[]{Color.WHITE, PaintCodeColor.colorByBlendingColors(Color.WHITE, 0.5f, Color.GRAY), Color.GRAY, PaintCodeColor.colorByBlendingColors(Color.GRAY, 0.5f, Color.GRAY), Color.GRAY, PaintCodeColor.colorByBlendingColors(Color.GRAY, 0.5f, Color.BLACK), Color.BLACK}, new float[]{0f, 0.1f, 0.28f, 0.5f, 0.72f, 0.9f, 1f});

        // Local Variables
        float maxWidth = 250f;
        float progressWidth = percent * maxWidth;

        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = ProgressBar.resizingBehaviorApply(resizing, new RectF(0f, 0f, 250f, 20f), targetFrame);
        canvas.translate(new PointF(resizedFrame.left, resizedFrame.top).x, new PointF(resizedFrame.left, resizedFrame.top).y);
        canvas.scale(resizedFrame.width() / 250f, resizedFrame.height() / 20f);

        // Rectangle
        RectF rectangleRect = new RectF(0f, 0f, 250f, 20f);
        Path rectanglePath = new Path();
        rectanglePath.addRect(rectangleRect, Path.Direction.CW);

        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setShader(gradient2.linearGradient(125f, 20f, 125f, 0f));
        canvas.drawPath(rectanglePath, paint);

        // Rectangle 2
        RectF rectangle2Rect = new RectF(0f, 0f, progressWidth, 20f);
        Path rectangle2Path = new Path();
        rectangle2Path.addRect(rectangle2Rect, Path.Direction.CW);

        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        RectF rectangle2PathBounds = new RectF();
        rectangle2Path.computeBounds(rectangle2PathBounds, true);
        paint.setStyle(Paint.Style.FILL);
        paint.setShader(gradient.linearGradient(rectangle2PathBounds.left, rectangle2PathBounds.bottom, rectangle2PathBounds.left, rectangle2PathBounds.top));
        canvas.drawPath(rectangle2Path, paint);

        canvas.restore();
    }


    // Resizing Behavior

    public static RectF resizingBehaviorApply(ResizingBehavior behavior, RectF rect, RectF target) {
        if (rect.equals(target) || target == null) {
            return rect;
        }

        if (behavior == ResizingBehavior.Stretch) {
            return target;
        }

        PointF ratio = new PointF();
        ratio.x = Math.abs(target.width() / rect.width());
        ratio.y = Math.abs(target.height() / rect.height());

        float scale = 0f;

        switch (behavior) {
            case AspectFit: {
                scale = Math.min(ratio.x, ratio.y);
                break;
            }
            case AspectFill: {
                scale = Math.max(ratio.x, ratio.y);
                break;
            }
            case Center: {
                scale = 1f;
                break;
            }
        }

        PointF newSize = new PointF(Math.abs(rect.width() * scale), Math.abs(rect.height() * scale));
        RectF result = new RectF(target.centerX(), target.centerY(), target.centerX(), target.centerY());
        result.inset(-newSize.x / 2f, -newSize.y / 2f);
        return result;
    }


}

class PaintCodeColor extends Color {
    private static float[] ColorToHSV(int originalColor) {
        float hsv[] = new float[3];
        RGBToHSV(red(originalColor), green(originalColor), blue(originalColor), hsv);
        return hsv;
    }

    public static int colorByChangingHue(int originalColor, float newHue) {
        float hsv[] = ColorToHSV(originalColor);
        hsv[0] = newHue;
        return HSVToColor(alpha(originalColor), hsv);
    }

    public static int colorByChangingSaturation(int originalColor, float newSaturation) {
        float hsv[] = ColorToHSV(originalColor);
        hsv[1] = newSaturation;
        return HSVToColor(alpha(originalColor), hsv);
    }

    public static int colorByChangingValue(int originalColor, float newValue) {
        float hsv[] = ColorToHSV(originalColor);
        hsv[2] = newValue;
        return HSVToColor(alpha(originalColor), hsv);
    }

    public static float hue(int color) {
        return ColorToHSV(color)[0];
    }

    public static float saturation(int color) {
        return ColorToHSV(color)[1];
    }

    public static float brightness(int color) {
        return ColorToHSV(color)[2];
    }

    public static int colorByChangingAlpha(int color, int newAlpha) {
        return argb(newAlpha, red(color), green(color), blue(color));
    }

    public static int colorByBlendingColors(int c1, float ratio, int c2) {
        return argb((int) ((1f - ratio) * alpha(c1) + ratio * alpha(c2)),
                (int) ((1f - ratio) * red(c1) + ratio * red(c2)),
                (int) ((1f - ratio) * green(c1) + ratio * green(c2)),
                (int) ((1f - ratio) * blue(c1) + ratio * blue(c2)));
    }

    public static int colorByApplyingHighlight(int color, float ratio) {
        return colorByBlendingColors(color, ratio, colorByChangingAlpha(WHITE, alpha(color)));
    }

    public static int colorByApplyingShadow(int color, float ratio) {
        return colorByBlendingColors(color, ratio, colorByChangingAlpha(BLACK, alpha(color)));
    }
}

class PaintCodeGradient {
    public int[] colors;
    public float[] positions;

    public PaintCodeGradient(int[] colors, float[] positions) {
        int steps = colors.length;
        if (positions == null)
        {
            positions = new float[steps];
            for (int i = 0; i < steps; i++)
                positions[i] = (float)i / (steps-1);
        }

        this.colors = colors;
        this.positions = positions;
    }

    public RadialGradient radialGradient(float startX, float startY, float startRadius, float endX, float endY, float endRadius)
    {
        float centerX = startX;
        float centerY = startY;

        if (startRadius > endRadius) {
            centerX = endX;
            centerY = endY;
        }

        PaintCodeGradient gradient = this.gradientForRadial(startRadius, endRadius);
        return new RadialGradient(centerX, centerY, Math.max(startRadius, endRadius), gradient.colors, gradient.positions, Shader.TileMode.CLAMP);
    }

    public LinearGradient linearGradient(float x0, float y0, float x1, float y1)
    {
        return new LinearGradient(x0, y0, x1, y1, this.colors, this.positions, Shader.TileMode.CLAMP);
    }

    private PaintCodeGradient gradientForRadial(float startRadius, float endRadius)
    {
        int[] colors;
        float[] positions;

        float ratio = startRadius / endRadius;
        int steps = this.colors.length;

        if (startRadius > endRadius)
        {
            colors = new int[steps];
            positions = new float[steps];

            for (int i = 0; i < steps; i++)
            {
                colors[i] = this.colors[steps - i - 1];
                positions[i] = 1 - this.positions[steps - i - 1];
                ratio = endRadius / startRadius;
            }
        }
        else
        {
            colors = this.colors;
            positions = this.positions.clone();
        }

        for (int i = 0; i < steps; i++)
            positions[i] = positions[i] * (1-ratio) + ratio;

        return new PaintCodeGradient(colors, positions);
    }
}