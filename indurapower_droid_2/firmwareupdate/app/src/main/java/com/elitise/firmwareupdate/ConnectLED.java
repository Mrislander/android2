package com.elitise.firmwareupdate;

import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.Matrix;
import android.graphics.PointF;
import android.graphics.RectF;
import android.graphics.Shader;
import android.graphics.LinearGradient;
import android.graphics.RadialGradient;
import android.graphics.BlurMaskFilter;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Path;
import java.util.Stack;



/**
 * Created by ShannonGreen on 1/17/17.
 * Copyright Â© 2017 InduraPower. All rights reserved.
 *
 * Generated by PaintCode
 * http://www.paintcodeapp.com
 *
 * @author ShannonGreen
 */
public class ConnectLED {
    // Resizing Behavior

    public enum ResizingBehavior {
        AspectFit, //!< The content is proportionally resized to fit into the target rectangle.
        AspectFill, //!< The content is proportionally resized to completely fill the target rectangle.
        Stretch, //!< The content is stretched to match the entire target rectangle.
        Center, //!< The content is centered in the target rectangle, but it is NOT resized.
    }

    // Canvas Drawings

    // Tab

    public static void drawCanvas1(Canvas canvas, int ledColor) {
        ConnectLED.drawCanvas1(canvas, new RectF(0f, 0f, 50f, 50f), ResizingBehavior.AspectFit, ledColor);
    }

    public static void drawCanvas1(Canvas canvas, RectF targetFrame, ResizingBehavior resizing, int ledColor) {
        // General Declarations
        Stack<Matrix> currentTransformation = new Stack<Matrix>();
        currentTransformation.push(new Matrix());
        Paint paint;

        // Local Colors
        int color9 = PaintCodeColor.colorByChangingSaturation(ledColor, 0f);
        int color8 = PaintCodeColor.colorByChangingSaturation(ledColor, 0.3f);
        int color7 = PaintCodeColor.colorByChangingSaturation(ledColor, 0.6f);

        // Local Gradients
        PaintCodeGradient ledGradient = new PaintCodeGradient(new int[]{ledColor, Color.WHITE}, new float[]{0f, 1f});

        // Local Shadows
        PaintCodeShadow shadow9 = new PaintCodeShadow(Color.WHITE, 0f, 0f, 3f);
        PaintCodeShadow shadow7 = new PaintCodeShadow(color9, 0f, 0f, 2f);
        PaintCodeShadow shadow5 = new PaintCodeShadow(color8, 0f, 0f, 2f);
        PaintCodeShadow shadow6 = new PaintCodeShadow(Color.BLACK, 2f, 1f, 5f);
        PaintCodeShadow ledShadow = new PaintCodeShadow(ledColor, 0f, 0f, 21f);

        // Resize to Target Frame
        canvas.save();
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        RectF resizedFrame = ConnectLED.resizingBehaviorApply(resizing, new RectF(0f, 0f, 50f, 50f), targetFrame);
        canvas.translate(new PointF(resizedFrame.left, resizedFrame.top).x, new PointF(resizedFrame.left, resizedFrame.top).y);
        canvas.scale(resizedFrame.width() / 50f, resizedFrame.height() / 50f);

        // Oval 3
        canvas.save();
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        canvas.translate(25.13f, 25.45f);
        currentTransformation.peek().postTranslate(25.13f, 25.45f);
        RectF oval3Rect = new RectF(-10f, -10f, 10f, 10f);
        Path oval3Path = new Path();
        oval3Path.addOval(oval3Rect, Path.Direction.CW);

        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        canvas.saveLayerAlpha(null, 255, Canvas.ALL_SAVE_FLAG);
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        {
            Matrix invertedCurrentTransformation = new Matrix();
            currentTransformation.peek().invert(invertedCurrentTransformation);
            canvas.concat(invertedCurrentTransformation);
            canvas.translate(ledShadow.dx, ledShadow.dy);
            canvas.concat(currentTransformation.peek());

            Paint shadowPaint = new Paint(paint);
            if (ledShadow.radius > 0f) {
                shadowPaint.setMaskFilter(new BlurMaskFilter(ledShadow.radius, BlurMaskFilter.Blur.NORMAL));
            }
            canvas.drawPath(oval3Path, shadowPaint);
            shadowPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
            canvas.saveLayer(null, shadowPaint, Canvas.ALL_SAVE_FLAG);
            currentTransformation.push(new Matrix(currentTransformation.peek()));
            {
                canvas.drawColor(ledShadow.color);
            }
            currentTransformation.pop();
            canvas.restore();
        }
        currentTransformation.pop();
        canvas.restore();
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(ledColor);
        canvas.drawPath(oval3Path, paint);
        canvas.saveLayerAlpha(null, 255, Canvas.ALL_SAVE_FLAG);
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        {

            paint = new Paint(Paint.ANTI_ALIAS_FLAG);
            paint.setColor(shadow6.color);
            canvas.drawPath(oval3Path, paint);

            paint = new Paint(Paint.ANTI_ALIAS_FLAG);
            paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));
            canvas.saveLayer(null, paint, Canvas.ALL_SAVE_FLAG);
            currentTransformation.push(new Matrix(currentTransformation.peek()));
            {
                Matrix invertedCurrentTransformation = new Matrix();
                currentTransformation.peek().invert(invertedCurrentTransformation);
                canvas.concat(invertedCurrentTransformation);
                canvas.translate(shadow6.dx, shadow6.dy);
                canvas.concat(currentTransformation.peek());


                paint = new Paint(Paint.ANTI_ALIAS_FLAG);
                paint.setColor(Color.WHITE);
                if (shadow6.radius > 0f) {
                    paint.setMaskFilter(new BlurMaskFilter(shadow6.radius, BlurMaskFilter.Blur.NORMAL));
                }
                canvas.drawPath(oval3Path, paint);
            }
            currentTransformation.pop();
            canvas.restore();
        }
        currentTransformation.pop();
        canvas.restore();

        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(0.5f);
        paint.setStrokeMiter(10f);
        canvas.save();
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.BLACK);
        canvas.drawPath(oval3Path, paint);
        currentTransformation.pop();
        canvas.restore();
        currentTransformation.pop();
        canvas.restore();

        // Bezier 8
        canvas.save();
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        canvas.translate(25.13f, 25.45f);
        currentTransformation.peek().postTranslate(25.13f, 25.45f);
        RectF bezier8Rect = new RectF(-0.23f, -3f, 8f, 8f);
        Path bezier8Path = new Path();
        bezier8Path.moveTo(7.23f, -3f);
        bezier8Path.cubicTo(7.72f, -1.95f, 8f, -0.76f, 8f, 0.51f);
        bezier8Path.cubicTo(8f, 4.65f, 5.05f, 8f, 1.41f, 8f);
        bezier8Path.cubicTo(0.84f, 8f, 0.3f, 7.92f, -0.23f, 7.77f);
        bezier8Path.cubicTo(4.06f, 6.78f, 7.27f, 2.73f, 7.27f, -2.11f);
        bezier8Path.cubicTo(7.27f, -2.41f, 7.26f, -2.71f, 7.23f, -3f);
        bezier8Path.close();

        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setShader(ledGradient.linearGradient(3.89f, -3f, 3.89f, 8f));
        canvas.drawPath(bezier8Path, paint);
        currentTransformation.pop();
        canvas.restore();

        // Oval 4
        canvas.save();
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        canvas.translate(25.17f, 25.7f);
        currentTransformation.peek().postTranslate(25.17f, 25.7f);
        RectF oval4Rect = new RectF(-5.05f, -5f, 4.95f, 5f);
        Path oval4Path = new Path();
        oval4Path.addOval(oval4Rect, Path.Direction.CW);

        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        canvas.saveLayerAlpha(null, 255, Canvas.ALL_SAVE_FLAG);
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        {
            Matrix invertedCurrentTransformation = new Matrix();
            currentTransformation.peek().invert(invertedCurrentTransformation);
            canvas.concat(invertedCurrentTransformation);
            canvas.translate(shadow5.dx, shadow5.dy);
            canvas.concat(currentTransformation.peek());

            Paint shadowPaint = new Paint(paint);
            if (shadow5.radius > 0f) {
                shadowPaint.setMaskFilter(new BlurMaskFilter(shadow5.radius, BlurMaskFilter.Blur.NORMAL));
            }
            canvas.drawPath(oval4Path, shadowPaint);
            shadowPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
            canvas.saveLayer(null, shadowPaint, Canvas.ALL_SAVE_FLAG);
            currentTransformation.push(new Matrix(currentTransformation.peek()));
            {
                canvas.drawColor(shadow5.color);
            }
            currentTransformation.pop();
            canvas.restore();
        }
        currentTransformation.pop();
        canvas.restore();
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(color7);
        canvas.drawPath(oval4Path, paint);
        currentTransformation.pop();
        canvas.restore();

        // Oval
        canvas.save();
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        canvas.translate(25.17f, 25.7f);
        currentTransformation.peek().postTranslate(25.17f, 25.7f);
        RectF ovalRect = new RectF(-3.05f, -3f, 2.95f, 3f);
        Path ovalPath = new Path();
        ovalPath.addOval(ovalRect, Path.Direction.CW);

        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        canvas.saveLayerAlpha(null, 255, Canvas.ALL_SAVE_FLAG);
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        {
            Matrix invertedCurrentTransformation = new Matrix();
            currentTransformation.peek().invert(invertedCurrentTransformation);
            canvas.concat(invertedCurrentTransformation);
            canvas.translate(shadow7.dx, shadow7.dy);
            canvas.concat(currentTransformation.peek());

            Paint shadowPaint = new Paint(paint);
            if (shadow7.radius > 0f) {
                shadowPaint.setMaskFilter(new BlurMaskFilter(shadow7.radius, BlurMaskFilter.Blur.NORMAL));
            }
            canvas.drawPath(ovalPath, shadowPaint);
            shadowPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
            canvas.saveLayer(null, shadowPaint, Canvas.ALL_SAVE_FLAG);
            currentTransformation.push(new Matrix(currentTransformation.peek()));
            {
                canvas.drawColor(shadow7.color);
            }
            currentTransformation.pop();
            canvas.restore();
        }
        currentTransformation.pop();
        canvas.restore();
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(color8);
        canvas.drawPath(ovalPath, paint);
        currentTransformation.pop();
        canvas.restore();

        // Oval 2
        canvas.save();
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        canvas.translate(25.17f, 25.7f);
        currentTransformation.peek().postTranslate(25.17f, 25.7f);
        RectF oval2Rect = new RectF(-1.5f, -1.5f, 1.5f, 1.5f);
        Path oval2Path = new Path();
        oval2Path.addOval(oval2Rect, Path.Direction.CW);

        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        canvas.saveLayerAlpha(null, 255, Canvas.ALL_SAVE_FLAG);
        currentTransformation.push(new Matrix(currentTransformation.peek()));
        {
            Matrix invertedCurrentTransformation = new Matrix();
            currentTransformation.peek().invert(invertedCurrentTransformation);
            canvas.concat(invertedCurrentTransformation);
            canvas.translate(shadow9.dx, shadow9.dy);
            canvas.concat(currentTransformation.peek());

            Paint shadowPaint = new Paint(paint);
            if (shadow9.radius > 0f) {
                shadowPaint.setMaskFilter(new BlurMaskFilter(shadow9.radius, BlurMaskFilter.Blur.NORMAL));
            }
            canvas.drawPath(oval2Path, shadowPaint);
            shadowPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
            canvas.saveLayer(null, shadowPaint, Canvas.ALL_SAVE_FLAG);
            currentTransformation.push(new Matrix(currentTransformation.peek()));
            {
                canvas.drawColor(shadow9.color);
            }
            currentTransformation.pop();
            canvas.restore();
        }
        currentTransformation.pop();
        canvas.restore();
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(color9);
        canvas.drawPath(oval2Path, paint);
        currentTransformation.pop();
        canvas.restore();

        currentTransformation.pop();
        canvas.restore();
    }


    // Resizing Behavior

    public static RectF resizingBehaviorApply(ResizingBehavior behavior, RectF rect, RectF target) {
        if (rect.equals(target) || target == null) {
            return rect;
        }

        if (behavior == ResizingBehavior.Stretch) {
            return target;
        }

        PointF ratio = new PointF();
        ratio.x = Math.abs(target.width() / rect.width());
        ratio.y = Math.abs(target.height() / rect.height());

        float scale = 0f;

        switch (behavior) {
            case AspectFit: {
                scale = Math.min(ratio.x, ratio.y);
                break;
            }
            case AspectFill: {
                scale = Math.max(ratio.x, ratio.y);
                break;
            }
            case Center: {
                scale = 1f;
                break;
            }
        }

        PointF newSize = new PointF(Math.abs(rect.width() * scale), Math.abs(rect.height() * scale));
        RectF result = new RectF(target.centerX(), target.centerY(), target.centerX(), target.centerY());
        result.inset(-newSize.x / 2f, -newSize.y / 2f);
        return result;
    }


}
//
//class PaintCodeColor extends Color {
//    private static float[] ColorToHSV(int originalColor) {
//        float hsv[] = new float[3];
//        RGBToHSV(red(originalColor), green(originalColor), blue(originalColor), hsv);
//        return hsv;
//    }
//
//    public static int colorByChangingHue(int originalColor, float newHue) {
//        float hsv[] = ColorToHSV(originalColor);
//        hsv[0] = newHue;
//        return HSVToColor(alpha(originalColor), hsv);
//    }
//
//    public static int colorByChangingSaturation(int originalColor, float newSaturation) {
//        float hsv[] = ColorToHSV(originalColor);
//        hsv[1] = newSaturation;
//        return HSVToColor(alpha(originalColor), hsv);
//    }
//
//    public static int colorByChangingValue(int originalColor, float newValue) {
//        float hsv[] = ColorToHSV(originalColor);
//        hsv[2] = newValue;
//        return HSVToColor(alpha(originalColor), hsv);
//    }
//
//    public static float hue(int color) {
//        return ColorToHSV(color)[0];
//    }
//
//    public static float saturation(int color) {
//        return ColorToHSV(color)[1];
//    }
//
//    public static float brightness(int color) {
//        return ColorToHSV(color)[2];
//    }
//
//    public static int colorByChangingAlpha(int color, int newAlpha) {
//        return argb(newAlpha, red(color), green(color), blue(color));
//    }
//
//    public static int colorByBlendingColors(int c1, float ratio, int c2) {
//        return argb((int) ((1f - ratio) * alpha(c1) + ratio * alpha(c2)),
//                (int) ((1f - ratio) * red(c1) + ratio * red(c2)),
//                (int) ((1f - ratio) * green(c1) + ratio * green(c2)),
//                (int) ((1f - ratio) * blue(c1) + ratio * blue(c2)));
//    }
//
//    public static int colorByApplyingHighlight(int color, float ratio) {
//        return colorByBlendingColors(color, ratio, colorByChangingAlpha(WHITE, alpha(color)));
//    }
//
//    public static int colorByApplyingShadow(int color, float ratio) {
//        return colorByBlendingColors(color, ratio, colorByChangingAlpha(BLACK, alpha(color)));
//    }
//}
//
//class PaintCodeGradient {
//    public int[] colors;
//    public float[] positions;
//
//    public PaintCodeGradient(int[] colors, float[] positions) {
//        int steps = colors.length;
//        if (positions == null)
//        {
//            positions = new float[steps];
//            for (int i = 0; i < steps; i++)
//                positions[i] = (float)i / (steps-1);
//        }
//
//        this.colors = colors;
//        this.positions = positions;
//    }
//
//    public RadialGradient radialGradient(float startX, float startY, float startRadius, float endX, float endY, float endRadius)
//    {
//        float centerX = startX;
//        float centerY = startY;
//
//        if (startRadius > endRadius) {
//            centerX = endX;
//            centerY = endY;
//        }
//
//        PaintCodeGradient gradient = this.gradientForRadial(startRadius, endRadius);
//        return new RadialGradient(centerX, centerY, Math.max(startRadius, endRadius), gradient.colors, gradient.positions, Shader.TileMode.CLAMP);
//    }
//
//    public LinearGradient linearGradient(float x0, float y0, float x1, float y1)
//    {
//        return new LinearGradient(x0, y0, x1, y1, this.colors, this.positions, Shader.TileMode.CLAMP);
//    }
//
//    private PaintCodeGradient gradientForRadial(float startRadius, float endRadius)
//    {
//        int[] colors;
//        float[] positions;
//
//        float ratio = startRadius / endRadius;
//        int steps = this.colors.length;
//
//        if (startRadius > endRadius)
//        {
//            colors = new int[steps];
//            positions = new float[steps];
//
//            for (int i = 0; i < steps; i++)
//            {
//                colors[i] = this.colors[steps - i - 1];
//                positions[i] = 1 - this.positions[steps - i - 1];
//                ratio = endRadius / startRadius;
//            }
//        }
//        else
//        {
//            colors = this.colors;
//            positions = this.positions.clone();
//        }
//
//        for (int i = 0; i < steps; i++)
//            positions[i] = positions[i] * (1-ratio) + ratio;
//
//        return new PaintCodeGradient(colors, positions);
//    }
//}
class PaintCodeShadow {
    public int color;
    public float dx;
    public float dy;
    public float radius;

    public PaintCodeShadow(int color, float dx, float dy, float radius) {
        this.color = color;
        this.dx = dx;
        this.dy = dy;
        this.radius = radius;
    }
}